/*
 * generated by Xtext 2.10.0
 */
package org.projektas.serializer;

import com.google.inject.Inject;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;
import org.projektas.mMK.Arithmetics;
import org.projektas.mMK.AssignmentExpression;
import org.projektas.mMK.Condition;
import org.projektas.mMK.ConditionalExpr;
import org.projektas.mMK.CreationExpression;
import org.projektas.mMK.ExprBody;
import org.projektas.mMK.FactorExpr;
import org.projektas.mMK.FactorExpression;
import org.projektas.mMK.GetLineExpression;
import org.projektas.mMK.GetNumExpression;
import org.projektas.mMK.MMKPackage;
import org.projektas.mMK.Model;
import org.projektas.mMK.Operation;
import org.projektas.mMK.PrintExpression;
import org.projektas.mMK.UnaryExpression;
import org.projektas.mMK.Value;
import org.projektas.mMK.Variable;
import org.projektas.mMK.WhileExpression;
import org.projektas.services.MMKGrammarAccess;

@SuppressWarnings("all")
public class MMKSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private MMKGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == MMKPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case MMKPackage.ARITHMETICS:
				sequence_Arithmetics(context, (Arithmetics) semanticObject); 
				return; 
			case MMKPackage.ASSIGNMENT_EXPRESSION:
				sequence_AssignmentExpression(context, (AssignmentExpression) semanticObject); 
				return; 
			case MMKPackage.CONDITION:
				sequence_Condition(context, (Condition) semanticObject); 
				return; 
			case MMKPackage.CONDITIONAL_EXPR:
				sequence_ConditionalExpr(context, (ConditionalExpr) semanticObject); 
				return; 
			case MMKPackage.CREATION_EXPRESSION:
				sequence_CreationExpression(context, (CreationExpression) semanticObject); 
				return; 
			case MMKPackage.EXPR_BODY:
				sequence_ExprBody(context, (ExprBody) semanticObject); 
				return; 
			case MMKPackage.FACTOR_EXPR:
				sequence_FactorExpr(context, (FactorExpr) semanticObject); 
				return; 
			case MMKPackage.FACTOR_EXPRESSION:
				sequence_FactorExpression(context, (FactorExpression) semanticObject); 
				return; 
			case MMKPackage.GET_LINE_EXPRESSION:
				sequence_GetLineExpression(context, (GetLineExpression) semanticObject); 
				return; 
			case MMKPackage.GET_NUM_EXPRESSION:
				sequence_GetNumExpression(context, (GetNumExpression) semanticObject); 
				return; 
			case MMKPackage.MODEL:
				sequence_Model(context, (Model) semanticObject); 
				return; 
			case MMKPackage.OPERATION:
				sequence_Operation(context, (Operation) semanticObject); 
				return; 
			case MMKPackage.PRINT_EXPRESSION:
				sequence_PrintExpression(context, (PrintExpression) semanticObject); 
				return; 
			case MMKPackage.UNARY_EXPRESSION:
				sequence_UnaryExpression(context, (UnaryExpression) semanticObject); 
				return; 
			case MMKPackage.VALUE:
				sequence_Value(context, (Value) semanticObject); 
				return; 
			case MMKPackage.VARIABLE:
				sequence_Variable(context, (Variable) semanticObject); 
				return; 
			case MMKPackage.WHILE_EXPRESSION:
				sequence_WhileExpression(context, (WhileExpression) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     Arithmetics returns Arithmetics
	 *
	 * Constraint:
	 *     ((m='*' | m='/' | m='+' | m='-') r=Primary)
	 */
	protected void sequence_Arithmetics(ISerializationContext context, Arithmetics semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     AbstractElement returns AssignmentExpression
	 *     Statement returns AssignmentExpression
	 *     Expression returns AssignmentExpression
	 *     AssignmentExpression returns AssignmentExpression
	 *
	 * Constraint:
	 *     (name=[Variable|QualifiedName] val=ExprBody)
	 */
	protected void sequence_AssignmentExpression(ISerializationContext context, AssignmentExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MMKPackage.Literals.ASSIGNMENT_EXPRESSION__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MMKPackage.Literals.ASSIGNMENT_EXPRESSION__NAME));
			if (transientValues.isValueTransient(semanticObject, MMKPackage.Literals.ASSIGNMENT_EXPRESSION__VAL) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MMKPackage.Literals.ASSIGNMENT_EXPRESSION__VAL));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAssignmentExpressionAccess().getNameVariableQualifiedNameParserRuleCall_0_0_1(), semanticObject.getName());
		feeder.accept(grammarAccess.getAssignmentExpressionAccess().getValExprBodyParserRuleCall_2_0(), semanticObject.getVal());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     AbstractElement returns Condition
	 *     Condition returns Condition
	 *
	 * Constraint:
	 *     (cond=ConditionalExpr then+=AbstractElement* else+=AbstractElement*)
	 */
	protected void sequence_Condition(ISerializationContext context, Condition semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ConditionalExpr returns ConditionalExpr
	 *
	 * Constraint:
	 *     (
	 *         left=ExprBody 
	 *         (
	 *             op='<' | 
	 *             op='<=' | 
	 *             op='>' | 
	 *             op='>=' | 
	 *             op='==' | 
	 *             op='!='
	 *         ) 
	 *         right=ExprBody
	 *     )
	 */
	protected void sequence_ConditionalExpr(ISerializationContext context, ConditionalExpr semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     AbstractElement returns CreationExpression
	 *     Statement returns CreationExpression
	 *     Expression returns CreationExpression
	 *     CreationExpression returns CreationExpression
	 *
	 * Constraint:
	 *     (type=Type name=Variable val=ExprBody?)
	 */
	protected void sequence_CreationExpression(ISerializationContext context, CreationExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ExprBody returns ExprBody
	 *
	 * Constraint:
	 *     expr+=FactorExpression+
	 */
	protected void sequence_ExprBody(ISerializationContext context, ExprBody semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Primary returns FactorExpr
	 *     FactorExpr returns FactorExpr
	 *
	 * Constraint:
	 *     (l=Primary a+=Arithmetics*)
	 */
	protected void sequence_FactorExpr(ISerializationContext context, FactorExpr semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     FactorExpression returns FactorExpression
	 *
	 * Constraint:
	 *     (l=Primary a+=Arithmetics*)
	 */
	protected void sequence_FactorExpression(ISerializationContext context, FactorExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     AbstractElement returns GetLineExpression
	 *     Statement returns GetLineExpression
	 *     Expression returns GetLineExpression
	 *     GetLineExpression returns GetLineExpression
	 *
	 * Constraint:
	 *     what=Value
	 */
	protected void sequence_GetLineExpression(ISerializationContext context, GetLineExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MMKPackage.Literals.GET_LINE_EXPRESSION__WHAT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MMKPackage.Literals.GET_LINE_EXPRESSION__WHAT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getGetLineExpressionAccess().getWhatValueParserRuleCall_1_0(), semanticObject.getWhat());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     AbstractElement returns GetNumExpression
	 *     Statement returns GetNumExpression
	 *     Expression returns GetNumExpression
	 *     GetNumExpression returns GetNumExpression
	 *
	 * Constraint:
	 *     what=Value
	 */
	protected void sequence_GetNumExpression(ISerializationContext context, GetNumExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MMKPackage.Literals.GET_NUM_EXPRESSION__WHAT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MMKPackage.Literals.GET_NUM_EXPRESSION__WHAT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getGetNumExpressionAccess().getWhatValueParserRuleCall_1_0(), semanticObject.getWhat());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Model returns Model
	 *
	 * Constraint:
	 *     elements+=AbstractElement+
	 */
	protected void sequence_Model(ISerializationContext context, Model semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     AbstractElement returns Operation
	 *     Operation returns Operation
	 *
	 * Constraint:
	 *     (name=QualifiedName (params+=QualifiedName params+=QualifiedName*)? type=Type body=Expression)
	 */
	protected void sequence_Operation(ISerializationContext context, Operation semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     AbstractElement returns PrintExpression
	 *     Statement returns PrintExpression
	 *     Expression returns PrintExpression
	 *     PrintExpression returns PrintExpression
	 *
	 * Constraint:
	 *     what=Value
	 */
	protected void sequence_PrintExpression(ISerializationContext context, PrintExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MMKPackage.Literals.PRINT_EXPRESSION__WHAT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MMKPackage.Literals.PRINT_EXPRESSION__WHAT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPrintExpressionAccess().getWhatValueParserRuleCall_1_0(), semanticObject.getWhat());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     AbstractElement returns UnaryExpression
	 *     Statement returns UnaryExpression
	 *     Expression returns UnaryExpression
	 *     Primary returns UnaryExpression
	 *     UnaryExpression returns UnaryExpression
	 *
	 * Constraint:
	 *     (val=Value us=UnarySuffix?)
	 */
	protected void sequence_UnaryExpression(ISerializationContext context, UnaryExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Value returns Value
	 *
	 * Constraint:
	 *     (var=[Variable|QualifiedName] | val=PrimitiveValue)
	 */
	protected void sequence_Value(ISerializationContext context, Value semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Variable returns Variable
	 *
	 * Constraint:
	 *     name=QualifiedName
	 */
	protected void sequence_Variable(ISerializationContext context, Variable semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MMKPackage.Literals.VARIABLE__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MMKPackage.Literals.VARIABLE__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getVariableAccess().getNameQualifiedNameParserRuleCall_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     AbstractElement returns WhileExpression
	 *     WhileExpression returns WhileExpression
	 *
	 * Constraint:
	 *     (end=ConditionalExpr loop+=AbstractElement*)
	 */
	protected void sequence_WhileExpression(ISerializationContext context, WhileExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
}
